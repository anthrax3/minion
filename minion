#!/usr/bin/env python2.7
"""Creates and manages a folder full of reminder files.

Usage: 
    minion count [--archives] <text> ...
    minion find [--archives] [--files] <text> ...
    minion here [--editor=<editor>] <text> ...  
    minion list [--archives] [--max=<max>] [--files] <text> ...
    minion note [--editor=<editor>] <text> ...  
    minion open [--archives] [--editor=<editor>] <text> ...
    minion publish [--archives] <target> <text> ...
    minion remind [--editor=<editor>] <text> ...
    minion sample [--files] <text> ...
    minion sort [--editor=<editor>] <text> ...
    minion strays
    minion summary [--archives] [--max=<max>] 
    minion tags

Options:
    -a --archives           Search archive folders for matches. 
    -e --editor=<editor>    Open files with the specified editor. [default: vim]
    -f --files              Display raw file names when listing files.
    -h --help               Show this help.
    --max=<max>             Maximum results to display. [default: 10]
    --version               Show version.

Command descriptions:
    count - display a count of the results.
    find - synonym for list 
    here - create a note in the current working directory
    list - list files matching keywords
    merge - find and merge similar files
    note - create a new note and then open it - <text> becomes filename
    remind - create a new file where <text> becomes filename
    sample - find up to 5 random results that match <text>
    sort - step through results matching <text>, tag, rename, sort into folders
    summary - list all folders and the item counts in those folders
    tags - list all tags

"""

# #babyTeddySays: m'0']..p p j\[ ''

# Copyright 2011-2012 Edward Delaporte <edthedev@gmail.com>
# Licensed under the University of Illinois / NCSA Open Source License 
# http://www.opensource.org/licenses/UoI-NCSA 
# Created: 2011-04-28

import os
import optparse
import shutil
import random

# DocOpt is awesome. https://github.com/docopt/docopt
from docopt import docopt

import brain_of_minion
import sys

CLEAN_INBOX_MESSAGE = '''*~*~*~*~*~*~*
 Clean Inbox
*~*~*~*~*~*~*
'''

args = docopt(__doc__, version='1.0')
# print args

# Interim code: Convert docopt args into options format from before.

directory = brain_of_minion.get_notes_home()
filter = args['<text>']

# Everything after this point requires searching for matches...
match_files = brain_of_minion.find_files(filter=args['<text>'], 
        archives=args['--archives'])

inbox_files = []

# Display a count of the matches 
if args['count']:
    search_terms = "%s: %s" % ( \
    os.path.basename(directory), ','.join(filter))
    count = len(match_files)
    print "%d - %s" % (count, search_terms)
    sys.exit()

# List the results
if args['list'] or args['find']:
    total_files = []

    # Set archives if no finds...
    if len(match_files) == 0:
        print "Found no matches. Searching archives..."
        match_files = brain_of_minion.find_files(filter=args['<text>'], 
                archives=True)
        total_files = brain_of_minion.find_files(archives=True)
    else:
        total_files = brain_of_minion.find_files()

    # Display results / total 
    match_template = \
"{matching} of {total} files match search {search} in directory {directory}"
    print match_template.format( \
    directory = brain_of_minion.get_notes_home(),
    matching=len(match_files), 
    search=','.join(args['<text>']), 
    total=len(total_files))
    
    # Display results
    brain_of_minion.display_output(title=filter, 
        output=match_files, 
        raw_files=args['--files'],
    )
    sys.exit(0)

# publish your articles.
if args['publish']:
    (choice_path, filename) = brain_of_minion.select_file(match_files)
    # brain_of_minion.open_file(filename, editor = args['--editor'])
    success = brain_of_minion.publish_file(filename, 
            editor = args['--editor'],
            target = args['<target>'],
        )
    if success != None:
        print "Published to " + success + "."

# note and remind verbs
if args['note'] or args['remind'] or args['here']:
    notes_dir = None

    if args['here']:
        notes_dir = os.curdir
    
    brain_of_minion.new_note(args['<text>'], 
            quick=args['remind'],
            editor=args['--editor'], 
            notes_dir=notes_dir)
    sys.exit(0)

# List just a sample of the matches 
if args['sample']:
    match_files = random.sample(match_files, 5)
    brain_of_minion.display_output(title=filter, output=match_files)

# Interactively sort the matches.
if args['sort']:
    total = len(match_files)
    if total == 0:
        print CLEAN_INBOX_MESSAGE
        sys.exit()
    else:
        print brain_of_minion.getOutput('cal')
        print brain_of_minion.get_inbox_menu()
        to_open = []
        weekend = not brain_of_minion.is_work_time()
        ignore_tags = brain_of_minion.get_ignore_tags(worktime=not weekend)
        count = 0
        to_open = []
        for item in match_files:
            count += 1
# Show progress...
            # print "-- %d/%d" % (count, total)
            print brain_of_minion.to_bar(count, total)
# The main call...
            files_to_open = brain_of_minion.doInboxInteractive(item)
            to_open.extend( files_to_open )

        if len(to_open) > 0:
            print "Files to open: %s" % '\n'.join(to_open)
            for item in to_open:
                brain_of_minion.open_file(item, 
                        multiple=True, editor=args['--editor'])

if args['open']:
    (choice_path, filename) = brain_of_minion.select_file(match_files)
    brain_of_minion.open_file(filename, editor = args['--editor'])

    # Merge the selected files.
#    if choice == '!merge':
#        trash_dir = os.path.expanduser("~/.trash")
#        if not os.path.exists(trash_dir):
#            os.mkdir(trash_dir)
#        new_contents = ''
#        for f in inbox_files:
#            new_contents += open(f, 'r').read()
#            shutil.move(f, trash_dir)
#            print "%s move to %s." % (f, trash_dir)
#        clean_name = brain_of_minion.createFileName(choice_path)
#        inbox_dir = brain_of_minion.get_inbox()
#        new_file_name = '%s/%s' % (inbox_dir, clean_name)
#        new_file = open(new_file_name, 'a')
#        new_file.write(new_contents)
#        new_file.close()
#        filename = new_file_name
#    elif choice == '!open':
#        for f in inbox_files:
#            brain_of_minion.open_file(f, editor=options.editor)
#    elif choice == '!list':
#        brain_of_minion.displayOutput('Matching', \
#                                    '\n'.join(inbox_files), \
#                                        by_tag=options.show_tags)
#

if args['summary']:
    summary = brain_of_minion.get_folder_summary(archives = args['--archives'])
    limit = int(args['--max'])
    summary = summary[:limit]
    for (count, folder) in summary:
        print "%s\t\t\t-\t%d" % (folder, count)

# Single box or all boxes...

def choose_files(minion_options):
    """Return a set of files to search within, 
        based on the options given on the command line."""
    if minion_options.filename != None:
        return [minion_options.filename]
    else:
        return brain_of_minion.find_files(directory=minion_options.directory,
            archives=minion_options.archive, 
            filter=minion_options.filter, 
            full_text=minion_options.full, 
            weekend=weekend)

# if options.directory == None:
#     options.directory = brain_of_minion.get_notes_home()
#     if len(ARGS) == 0:
#         options.directory = brain_of_minion.get_inbox()
# options.directory = brain_of_minion.get_notes_home()

if args['strays']:
    
    # All poorly tagged files...
    updated_files = []
    match_files = brain_of_minion.find_files()
    for item in match_files:
        if len(brain_of_minion.get_tags(item)) < 2:
            updated_files.append(item)

    # All poorly used folders
    notes_home = brain_of_minion.get_notes_home()
    for folder in os.listdir(brain_of_minion.get_notes_home()):
        folder = os.path.join(notes_home, folder)
        if os.path.isdir(folder):
            if len(os.listdir(folder)) < 3:
                items = brain_of_minion.find_files(filter=folder)
                for item in items:
                    updated_files.append(item)

    match_files = updated_files

    for item in match_files:
        files_to_open = brain_of_minion.doInboxInteractive(item)

