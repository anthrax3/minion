#!/usr/bin/env python2.7
"""Creates and manages a folder full of reminder files.

Usage:
    minion collect [--archives] [--year=<year>] <text> ...
    minion count [--archives] <text> ...
    minion command <command> <filename>
    minion dates <text> ...
    minion find [--archives] [--files] <text> ...
    minion favorites
    minion folder <text> ...
    minion folders
    minion here [--editor=<editor>] <text> ...
    minion list [--archives] [--max=<max>] [--files] <text> ...
    minion log <log> <comment> ...
    minion note [--folder=<folder>] [--editor=<editor>] <text> ...
    minion open [--archives] [--editor=<editor>] [--max=<max>] <text> ...
    minion remind [--folder=<folder>] [--editor=<editor>] <text> ...
    minion sample [--files] <text> ...
    minion sort [--editor=<editor>] <text> ...
    minion strays
    minion summary [--archives] [--max=<max>]
    minion view [--archives] [--max=<max>] <text> ...
    minion tags
    minion template [--folder=<folder>] <template> [<text>] ...

Options:
    -a --archives           Search archive folders for matches.
    -e --editor=<editor>    Open files with the specified editor. [default: vim]
    -f --files              Display raw file names when listing files.
    -F --folder=<folder>    Place the new note into the given folder.
    -h --help               Show this help.
    --max=<max>             Maximum results to display. [default: 10]
    -y --year=<year>        Limit results to those created in the given year.
    --version               Show version.

Command descriptions:
    count - display a count of the results
    dates - display matching files with dates, in date order
    find - like list, but returns *any* match to *any* given keyword.
    favorites - like summary, but displays only folders configured as favorites
    folder - find an open a folder
    folders - reduce folders by sorting items in folders with fewer items
    here - create a note in the current working directory
    journal - open a new or existing file named journal.<today>.txt
    list - list files matching keywords
    log - add a line with the current date and time to a file.
    merge - find and merge similar files
    note - create a new note and then open it - <text> becomes filename
    remind - create a new file where <text> becomes filename
    sample - find up to 5 random results that match <text>
    sort - step through results matching <text>
            tag, rename, and sort files into folders
    strays - interactively sort any files whose folder only contains
            a few items.
    summary - list all folders and the item counts in those folders
    view - print the contents of all matches to the terminal standard output
    week - plan your week with the minion week template
    tags - list all tags
    template - start a note from a specialized template. Try 'week' and
            'journal' to get started.
"""

# #babyTeddySays: m'0']..p p j\[ ''

# Copyright 2011-2012 Edward Delaporte <edthedev@gmail.com>
# Licensed under the University of Illinois / NCSA Open Source License
# http://www.opensource.org/licenses/UoI-NCSA
# Created: 2011-04-28


###############################################################################
# IMPORTS
###############################################################################

# import pudb; pu.db
import os
import datetime
# DocOpt is awesome. https://github.com/docopt/docopt
from docopt import docopt
import brain_of_minion as brain
from brain_of_minion import get_date_format
import sys


###############################################################################
# CONSTANTS
###############################################################################

CLEAN_INBOX_MESSAGE = '''*~*~*~*~*~*~*
 Clean Inbox
*~*~*~*~*~*~*
'''

CLEAN_STRAYS_MESSAGE = '''*~*~*~*~*~*~*
 No stray items
*~*~*~*~*~*~*
'''


###############################################################################
# HELPER FUNCTIONS
###############################################################################

def get_match_files():
    match_files = brain.find_files(
        filter=args['<text>'],
        archives=args['--archives'])
    return match_files


def should_collect(filename):
    filename, ext = os.path.splitext(filename)
    allowed_ext = ['.txt', '.rst']
    if ext in allowed_ext:
        # Hack to avoid collecting collections.
        if 'Collected' not in filename:
            return True
    return False


def date_sort(filename):
    '''Provide a date sort that puts None first.'''
    if brain.get_first_date(filename):
        return brain.get_first_date(filename)
    return datetime.datetime.now()


def get_notes_dir(args):
    notes_dir = None
    if args['--folder']:
        folder = os.path.expanduser(args['--folder'])
        notes_home = brain.get_notes_home()
        notes_dir = os.path.join(notes_home, folder)
    return notes_dir


def format_2_cols(tuple_list):
    SEPARATOR = " - "
    PADDING = ' '
    output = []

    col_max = {}

    # Find longest column members
    for tup in tuple_list:
        line = ""
        col = 0
        for item in tup:
            item = str(item)
            col += 1
            if item not in col_max:
                col_max[col] = 0
            if len(item) > col_max[col]:
                col_max[col] = len(item)

    # Build the string
    for tup in tuple_list:
        col = 0
        line = ""
        for item in tup:
            item = str(item)
            col += 1

            # Separator when needed.
            if len(line) != 0:
                line += SEPARATOR

            # Padded line item.
            while len(item) < col_max[col]:
                item += PADDING
            line += item
        output.append(line)
    output = '\n'.join(output)
    return output


###############################################################################
# ENTRY POINT FUNCTIONS
###############################################################################

def minion_template(args):
    '''Create a Minion note from a specialized template.'''
    template_content = brain.get_template_content(args['<template>'])
    title = brain.get_title_from_template_content(template_content,
                                                  topic=args['<text>'])
    args['<text>'].insert(0, title)
    (filename, last_line) = brain.create_new_note(
        ' '.join(args['<text>']),
        template=args['<template>'],
    )
    brain.open_file(filename, last_line)


def minion_remind(args):
    '''Set a quick reminder.'''
    notes_dir = get_notes_dir(args)
    default_template = brain.get_setting('note', 'default_template')
    brain.new_note_interactive(
        args['<text>'],
        quick=args['remind'],
        template=default_template,
        notes_dir=notes_dir)


def minion_here(args):
    '''Create a Minion note in the current working directory.'''
    notes_dir = os.curdir
    default_template = brain.get_setting('note', 'default_template')
    brain.new_note_interactive(
        args['<text>'],
        quick=args['remind'],
        template=default_template,
        notes_dir=notes_dir)


def minion_note(args):
    '''Create a Minion note.'''
    notes_dir = get_notes_dir(args)
    default_template = brain.get_setting('note', 'default_template')
    brain.new_note_interactive(
        args['<text>'],
        quick=args['remind'],
        template=default_template,
        notes_dir=notes_dir)


def minion_sort(args):
    '''Interactively sort all matches.
    '''
    match_files = get_match_files()
    total = len(match_files)
    if total == 0:
        print CLEAN_INBOX_MESSAGE
        sys.exit()
    else:
        print brain.getOutput('cal')
        brain.sort_files_interactive(match_files)


def minion_open(args):
    match_files = brain.find_files(
        filter=args['<text>'],
        archives=args['--archives'])

    if len(match_files) > 0:
        (choice_path, filename) = brain.select_file(match_files, args['--max'])
        brain.open_file(filename)
    else:
        brain.display_output(title=filter, output=match_files)


def minion_strays(args):
    ''' Run an interactive sort on the contents of any folders that
        only have one or two items.
    '''
    match_files = brain.list_stray_files()
    total = len(match_files)
    if total == 0:
        print CLEAN_STRAYS_MESSAGE
        sys.exit()
    else:
        print brain.getOutput('cal')
        brain.sort_files_interactive(match_files)


def minion_view(args):
    ''' Dump the contents of the chosen file(s) to standard out. '''
    match_files = brain.find_files(
        filter=args['<text>'],
        archives=args['--archives'])
    print "Outputting contents of %(number)d matches to search terms \
        '%(terms)s'.".format(number=len(match_files), terms=args['<text>'])
    for filename in match_files:
        brain.file_to_stdout(filename)


def minion_log(args):
    '''Add a quick additional line to an existing (or new) Minion file.'''
    filename = ''
    match_files = brain.find_files(
        filter=[args['<log>']],
        archives=args['--archives'])
    if len(match_files) > 1:
        title = ("Too many matches for log "
                 "function with keyword '{}'").format(args['<log>'])
        brain.display_output(title, match_files, max_display=10)
        return False
    elif len(match_files) == 1:
        filename = match_files[0]
    else:
        print "Creating new log file..."
        filename = brain.get_filename_for_title(args['<log>'])

    data = dict()
    data.update(args)
    data['date'] = datetime.datetime.today().strftime(get_date_format())
    data['time'] = datetime.datetime.today().strftime("%H:%M")
    data['<comment>'] = ' '.join(args['<comment>'])
    # TODO: select_file should probably create the file if it does not exist...
    #  This would allow merging the 'note' and 'open' commands, resulting in
    #  less duplication with new notes, and less need to call collect.
    # TODO: Make this fetch from config file.
    # TODO: Make match template fetch from config file too...
    new_line_template = "\n{date} {time} : {<comment>}"
    new_line = new_line_template.format(**data)

    print "Appending new line to %s" % filename
    f = open(filename, 'a')
    f.write(new_line)
    f.close()
    print new_line


###############################################################################
# MAIN SCRIPT
###############################################################################

# Parse the input arguments; see docopt manual on github.com
args = docopt(__doc__, version='1.0')

# Search terms to filter by.
filter = args['<text>']
if args['<text>'] == 'all':
    args['<text>'] = None

# Everything after this point requires searching for matches...

# Collect stories
if args['collect']:
    if '<year>' in args:
        YEAR = args['<year>']
        match_files = get_match_files()
        collected_matches = brain.limit_to_year(YEAR, match_files)
        collection_title = 'Collected-%s-%s' % (YEAR, ' '.join(filter))

        print "%d/%d %s stories occur in year %s" % (
            len(collected_matches),
            len(match_files),
            filter,
            str(YEAR),
        )
    else:
        collected_matches = match_files
        collection_title = 'Collected-%s' % (' '.join(filter))

    brain.display_output(collection_title, collected_matches)

    collected_string = collection_title

    sorted_matches = sorted(collected_matches, key=date_sort)

    for filename in sorted_matches:
        # Don't include past collections...
        if should_collect(filename):
            f = open(filename, 'r')
            lines = f.read()
            f.close()
            collected_string += '\n'
            collected_string += '\n'
            collected_string += lines

    collected_filename = brain.get_filename_for_title(collection_title)

    f = open(collected_filename, 'w')
    f.write(collected_string)
    f.close()
    brain.display_output('Created Collection', collected_filename)


if args['command'] and args['<command>'] and args['<filename>']:
    brain.apply_command_to_file(
        args['<filename>'],
        args['<command>'])

if args['count']:
    search_terms = "%s: %s" % (
        os.path.basename(brain.get_notes_home()), ','.join(args['<text>'])
    )
    match_files = get_match_files()
    count = len(match_files)
    print "%d - %s" % (count, search_terms)
    sys.exit()

if args['dates']:
    total = brain.get_total_file_count(include_archives=False)
    events = dict()
    match_files = get_match_files()
    for filename in match_files:
        date = brain.get_first_date(filename)
        if date:
            try:
                if date in events:
                    events[date].append(filename)
                else:
                    events[date] = [filename]
            except ValueError:
                # Date before 1900
                pass

    today = datetime.datetime.today()
    today_str = today.strftime(get_date_format())
    recent_date = today - datetime.timedelta(days=14)
    upcoming = dict()
    recent = dict()
    for key in events:
        if key > today:
            datestr = key.strftime(get_date_format())
            upcoming[datestr] = events[key]
        elif key > recent_date:
            datestr = key.strftime(get_date_format())
            recent[datestr] = events[key]

    # for key in events:
    #     print key.strftime(get_date_format()) + "\t" + events[key]

    brain.display_output('Recent Dates', recent)
    brain.display_output('Today', today_str)
    brain.display_output('Upcoming Dates', upcoming)

# List the results

if args['find'] or args['list']:
    find_any = False
    if args['find']:
        find_any = True
    match_files = brain.find_files(filter=filter, archives=args['--archives'],
                                   find_any=find_any)

    # Set archives if no finds...
    total = brain.get_total_file_count(args['--archives'])

    # Display results / total
    notes_home = brain.get_notes_home()
    match_template = "{matching} of {total} files match search \
        {search} in directory {directory}"
    print match_template.format(
        directory=notes_home,
        matching=len(match_files),
        search=','.join(filter),
        total=total)

    # Display results
    # print match_files
    brain.display_output(
        title=filter,
        output=match_files,
        raw_files=args['--files'],
    )

    sys.exit(0)

if args['favorites']:
    print brain.print_favorites_summary()

if args['summary']:
    summary = brain.get_folder_summary(archives=args['--archives'])
    limit = int(args['--max'])
    summary = summary[:limit]
    output = format_2_cols(summary)
    print output

if args['folder']:
    # TODO: Do interactive inbox search, but for directories, not files
    pass

if args['folders']:
    updated_files = []
    # match_files = get_match_files()
    match_files = brain.find_files()
    # All poorly used folders
    too_few = 5
    notes_home = brain.get_notes_home()
    for folder in os.listdir(brain.get_notes_home()):
        folder = os.path.join(notes_home, folder)
        if os.path.isdir(folder):
            if len(os.listdir(folder)) < too_few:
                items = brain.find_files(filter=folder)
                for item in items:
                    updated_files.append(item)

    match_files = updated_files

    total = len(match_files)
    count = 0
    for item in match_files:
        count += 1
        print brain.to_bar(count, total)
        files_to_open = brain.doInboxInteractive(item)

if args['tags']:
    # TODO: Rid of this. Concept of 'tags' does not play well with the
    #       filesystem.
    # TODO: Switch to simply using any word as a 'tag'.
    # So what is 'poorly tagged'? Too short of a name? Too many common words?

    # A 'tag cloud' would be pretty awesome...
    boring = ['the', 'this']
    notes_home = brain.get_notes_home()
    all_files = brain.find_files()
    word_count = dict()
    for filename in all_files:
        filename = filename.replace(notes_home, '')
        filename = filename.replace('/', '-').replace('.', '-')
        words = filename.split('-')
        print words
        for word in words:
            if word in word_count:
                word_count[word] += 1
            else:
                word_count[word] = 1
    # word_count.sort()
    print word_count


# Run all the things!!!!
if __name__ == '__main__':
    # Run any method named in the keyword args.
    # Cool hack: use DocOpt args to call methods in this file.
    # Note that this only avails those methods whose name matches a documented
    #     arg.
    for method in dir():
        argname = method.replace('minion_', '')
        if (argname in args) and args[argname]:
            if hasattr(locals()[method], '__call__'):
                print "Running {}".format(method)
                locals()[method](args)

sys.exit(0)
