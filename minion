#!/usr/bin/env python2.7
"""Creates and manages a folder full of reminder files.

Usage: 
    minion count [--archives] <text> ...
    minion find [--archives] [--files] <text> ...
    minion list [--archives] [--max=<max>] [--files] <text> ...
    minion note [--editor=<editor>] <text> ...  
    minion open [--archives] [--editor=<editor>] <text> ...
    minion publish [--archives] <target> <text> ...
    minion remind [--editor=<editor>] <text> ...
    minion sample [--files] <text> ...
    minion sort [--editor=<editor>] <text> ...
    minion summary 

Options:
    -a --archives           Search archive folders for matches. 
    -e --editor=<editor>    Open files with the specified editor. [default: vim]
    -f --files              Display raw file names when listing files.
    -h --help               Show this help.
    --max=<max>             Maximum results to display. [default: 10]
    --version               Show version.

Command descriptions:
    count - display a count of the results.
    find - synonym for list 
    list - list files matching keywords
    note - create a new note and then open it - <text> becomes filename
    remind - create a new file where <text> becomes filename
    sample - find up to 5 random results that match <text>
    sort - step through results matching <text>, tag, rename, sort into folders

"""

# #babyTeddySays: m'0']..p p j\[ ''

# Copyright 2011-2012 Edward Delaporte <edthedev@gmail.com>
# Licensed under the University of Illinois / NCSA Open Source License 
# http://www.opensource.org/licenses/UoI-NCSA 
# Created: 2011-04-28

import os
import optparse
import shutil
import random

# DocOpt is awesome. https://github.com/docopt/docopt
from docopt import docopt

import brain_of_minion
import sys

CLEAN_INBOX_MESSAGE = '''*~*~*~*~*~*~*
 Clean Inbox
*~*~*~*~*~*~*
'''

args = docopt(__doc__, version='1.0')
# print args

# Interim code: Convert docopt args into options format from before.

directory = brain_of_minion.get_notes_home()
filter = args['<text>']

# Everything after this point requires searching for matches...
match_files = brain_of_minion.find_files(filter=args['<text>'], 
        archives=args['--archives'])

inbox_files = []

# Display a count of the matches 
if args['count']:
    search_terms = "%s: %s" % ( \
    os.path.basename(directory), ','.join(filter))
    count = len(match_files)
    print "%d - %s" % (count, search_terms)
    sys.exit()

# List the results
if args['list'] or args['find']:
    total_files = []

    # Set archives if no finds...
    if len(match_files) == 0:
        print "Found no matches. Searching archives..."
        match_files = brain_of_minion.find_files(filter=args['<text>'], 
                archives=True)
        total_files = brain_of_minion.find_files(archives=True)
    else:
        total_files = brain_of_minion.find_files()

    # Display results / total 
    match_template = \
"{matching} of {total} files match search {search} in directory {directory}"
    print match_template.format( \
    directory = brain_of_minion.get_notes_home(),
    matching=len(match_files), 
    search=','.join(args['<text>']), 
    total=len(total_files))
    
    # Display results
    brain_of_minion.display_output(title=filter, output=match_files)
    sys.exit(0)

# publish your articles.
if args['publish']:
    (choice_path, filename) = brain_of_minion.select_file(match_files)
    # brain_of_minion.open_file(filename, editor = args['--editor'])
    success = brain_of_minion.publish_file(filename, 
            editor = args['--editor'],
            target = args['<target>'],
        )
    if success != None:
        print "Published to " + success + "."

# note and remind verbs
if args['note'] or args['remind']:
    brain_of_minion.new_note(args['<text>'], 
            quick=args['remind'],
            editor=args['--editor'])
    sys.exit(0)

# List just a sample of the matches 
if args['sample']:
    match_files = random.sample(match_files, 5)
    brain_of_minion.display_output(title=filter, output=match_files)

# Interactively sort the matches.
if args['sort']:
    total = len(match_files)
    if total == 0:
        print CLEAN_INBOX_MESSAGE
        sys.exit()
    else:
        print brain_of_minion.getOutput('cal')
        print brain_of_minion.get_inbox_menu()
        to_open = []
        weekend = not brain_of_minion.is_work_time()
        ignore_tags = brain_of_minion.get_ignore_tags(worktime=not weekend)
        count = 0
        to_open = []
        for item in match_files:
            count += 1
# Show progress...
            # print "-- %d/%d" % (count, total)
            print brain_of_minion.to_bar(count, total)
# The main call...
            files_to_open = brain_of_minion.doInboxInteractive(item)
            to_open.extend( files_to_open )

        if len(to_open) > 0:
            print "Files to open: %s" % '\n'.join(to_open)
            for item in to_open:
                brain_of_minion.open_file(item, 
                        multiple=True, editor=args['--editor'])

if args['open']:
    (choice_path, filename) = brain_of_minion.select_file(match_files)
    brain_of_minion.open_file(filename, editor = args['--editor'])

    # Merge the selected files.
#    if choice == '!merge':
#        trash_dir = os.path.expanduser("~/.trash")
#        if not os.path.exists(trash_dir):
#            os.mkdir(trash_dir)
#        new_contents = ''
#        for f in inbox_files:
#            new_contents += open(f, 'r').read()
#            shutil.move(f, trash_dir)
#            print "%s move to %s." % (f, trash_dir)
#        clean_name = brain_of_minion.createFileName(choice_path)
#        inbox_dir = brain_of_minion.get_inbox()
#        new_file_name = '%s/%s' % (inbox_dir, clean_name)
#        new_file = open(new_file_name, 'a')
#        new_file.write(new_contents)
#        new_file.close()
#        filename = new_file_name
#    elif choice == '!open':
#        for f in inbox_files:
#            brain_of_minion.open_file(f, editor=options.editor)
#    elif choice == '!list':
#        brain_of_minion.displayOutput('Matching', \
#                                    '\n'.join(inbox_files), \
#                                        by_tag=options.show_tags)
#

if args['summary']:
    notes_home = brain_of_minion.get_notes_home()
    folders = os.listdir(notes_home)
    for folder in folders:
        matches = match_files = brain_of_minion.find_files(filter=folder, 
                archives = args['--archives'])
        print "%s\t\t\t-\t%d" % (folder, len(matches))

# Everything below this is legacy...still being integrated.

# Process inbox...
#     if options.sample:

    

# ----------------------------------
# Main interactive loop...
# ----------------------------------
# def open_main():
#     "Open the main organizer file, for users who are using such a file."
#     main_org_file = "%s/projects/main.org" % brain_of_minion.get_notes_home()
#     print main_org_file
#     brain_of_minion.open_file(main_org_file, editor=options.editor)

# Certain options logically imply other options as well.
#    This limits how the user can use this app, but 
#        steers the user toward better user experiences.

# options.main_file = False

# if options.raw == True:
#     options.show_tags = False

# if len(ARGS) == 0:
#     options.silent = True

# if options.remind:
#     options.new_note = True
#     options.quick = True

# if options.search: 
#     options.full = True

# if options.count: 
#     options.silent = True
# if options.main_file: 
#     options.silent = True

# if options.sample: 
#     options.quick = True 
# if options.review: 
#     options.quick = True
# if options.filename != None: 
#     options.quick = True

# if options.quick: 
#     options.archive = False
#     options.full = False

# if options.list:
#     options.silent = True

# If they didn't ask for a non-interactive session, 
#   prompt for the options they forgot to specify.
# options.quick overrides this behavior 
#   by setting these options before we get here.
# Quite a few other options set options.quick=True 
#   in order to enforce their intended user experience.
#if not options.silent:
    #if options.archive == None:
        #answer = raw_input('Search archives?')
        #if 'y' in answer.lower():
            #options.archive = True
        #else:
            #options.archive = False
    #if options.full == None:
        #answer = raw_input('Full text search?')
        #if 'y' in answer.lower():
            #options.full = True
        #else:
            #options.full = False


# if options.weekend:
#     weekend = not weekend

# Single box or all boxes...

def choose_files(minion_options):
    """Return a set of files to search within, 
        based on the options given on the command line."""
    if minion_options.filename != None:
        return [minion_options.filename]
    else:
        return brain_of_minion.find_files(directory=minion_options.directory,
            archives=minion_options.archive, 
            filter=minion_options.filter, 
            full_text=minion_options.full, 
            weekend=weekend)

# if options.directory == None:
#     options.directory = brain_of_minion.get_notes_home()
#     if len(ARGS) == 0:
#         options.directory = brain_of_minion.get_inbox()
# options.directory = brain_of_minion.get_notes_home()

# if len(ARGS) > 0:
#     options.filter.extend(ARGS)

# options.filter = args['text']

# inbox_files = []
# inbox_files = choose_files(options)

# If we are along looking for orphaned files...
# if options.notags:
#    updated_inbox_files = []
#    for item in inbox_files:
#        if len(brain_of_minion.getTags(item)) < 2:
#            updated_inbox_files.append(item)
#    inbox_files = updated_inbox_files
#
# if not options.silent: 
#     print "Searching directory %s." % (options.directory)


# if len(options.ignore) > 0:
#     search_terms = [item.lower() for item in options.ignore]
#     ignore_tags.extend(search_terms)
# if not options.silent: 
#     print "Ignoring %s" % ','.join(ignore_tags)

# Open all results
# if options.open_all:
#     for item in inbox_files:
#         brain_of_minion.open_file(item, multiple=True, editor=options.editor)
#     sys.exit() 
